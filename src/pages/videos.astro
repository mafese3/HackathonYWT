---
import BaseLayout from '../layouts/BaseLayout.astro'
import VideoCard from '../components/VideoCard.astro'

const videos = [
  
  { title: "YouTube Short", author: "Creador", youtubeId: "MPOxYXVy2Bs" },
  { title: "YouTube Short", author: "Creador", youtubeId: "MMPCWQJpSho" },
  { title: "YouTube Short", author: "Creador", youtubeId: "XQZLzpsrxlA" },
  { title: "YouTube Short", author: "Creador", youtubeId: "uA6vy5x9OGQ" },
  { title: "YouTube Short", author: "Creador", youtubeId: "ieWm4sAtvOk" },
  { title: "YouTube Short", author: "Creador", youtubeId: "kM5kfsB5Boo" }
];
---

<style>
  .snap-container {
    height: calc(100vh - 4rem); /* Altura total menos el header */
    overflow-y: hidden;
    scroll-snap-type: y mandatory;
    position: relative;
  }

  .nav-arrows-container {
    position: fixed;
    right: max(1rem, calc((100% - 48rem) / 2 + 1rem)); /* 48rem = max-w-3xl (768px) */
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    z-index: 10;
  }

  .nav-arrow {
    background: rgba(0, 0, 0, 0.5);
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .nav-arrow:hover {
    background: rgba(0, 0, 0, 0.7);
    transform: scale(1.1);
  }

  .nav-arrow.hidden {
    opacity: 0;
    pointer-events: none;
  }
</style>

<BaseLayout>
  <div slot="content" class="relative">
    <div class="snap-container" id="videos-container">
      {videos.map((video, index) => (
        <VideoCard 
          title={video.title} 
          author={video.author} 
          videoId={video.youtubeId}
          data-index={index}
        />
      ))}
    </div>

    <div class="nav-arrows-container">
      <button class="nav-arrow hidden" aria-label="Video anterior">
        <span class="material-symbols-outlined">keyboard_arrow_up</span>
      </button>
      <button class="nav-arrow" aria-label="Siguiente video">
        <span class="material-symbols-outlined">keyboard_arrow_down</span>
      </button>
    </div>
  </div>

  <script>
    // Definiciones de tipos para la API de YouTube
    declare global {
      interface Window {
        onYouTubeIframeAPIReady: () => void;
        YT: any;
      }
      const YT: any;
    }
    
    // Cargar la API de YouTube IFrame
    let tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    let firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    const container = document.getElementById('videos-container');
    const [upButton, downButton] = document.querySelectorAll('.nav-arrow');
    const videoElements = container.children;
    let currentIndex = 0;
    let players = [];

    // Función que se llamará cuando la API de YouTube esté lista
    window.onYouTubeIframeAPIReady = function() {
      // Inicializar solo los players de YouTube
      document.querySelectorAll('.youtube-video').forEach((video) => {
        const videoContainer = video.closest('.video-container');
        const containerIndex = Array.from(videoElements).indexOf(videoContainer);
        
        players[containerIndex] = new YT.Player(video, {
          events: {
            'onReady': (event) => {
              // Reproducir el primer video automáticamente si es YouTube
              if (containerIndex === 0) {
                event.target.playVideo();
              }
            }
          }
        });
      });
    };

    function updateNavigation() {
      // Los botones siempre están visibles para navegación infinita
      if (upButton) upButton.classList.remove('hidden');
      if (downButton) downButton.classList.remove('hidden');
    }

    function scrollToVideo(index) {
      // Pausar el video actual
      if (players[currentIndex]) {
        players[currentIndex].pauseVideo();
      }

      let newIndex = index;
      let isLooping = false;

      // Hacer bucle infinito
      if (index < 0) {
        newIndex = videoElements.length - 1;
        isLooping = true;
      } else if (index >= videoElements.length) {
        newIndex = 0;
        isLooping = true;
      }

      // Si es un bucle, scroll instantáneo; si no, suave
      videoElements[newIndex].scrollIntoView({ 
        behavior: isLooping ? 'auto' : 'smooth' 
      });
      currentIndex = newIndex;

      // Reproducir el nuevo video
      if (players[newIndex]) {
        players[newIndex].seekTo(0);
        players[newIndex].playVideo();
      }

      updateNavigation();
    }

    // Event listeners para los botones
    upButton?.addEventListener('click', () => scrollToVideo(currentIndex - 1));
    downButton?.addEventListener('click', () => scrollToVideo(currentIndex + 1));

    // Event listener para teclas de flecha
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        scrollToVideo(currentIndex - 1);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        scrollToVideo(currentIndex + 1);
      }
    });

    // Variables para swipe/deslizamiento (touch y mouse)
    let startY = 0;
    let endY = 0;
    let isDragging = false;
    const minSwipeDistance = 50; // Píxeles mínimos para considerar un swipe

    // Obtener todas las capas de swipe
    const swipeOverlays = document.querySelectorAll('.swipe-overlay');

    swipeOverlays.forEach(overlay => {
      // Event listeners para touch (móvil)
      overlay.addEventListener('touchstart', (e: TouchEvent) => {
        startY = e.touches[0].clientY;
      }, { passive: true });

      overlay.addEventListener('touchmove', (e: TouchEvent) => {
        endY = e.touches[0].clientY;
      }, { passive: true });

      overlay.addEventListener('touchend', () => {
        handleSwipe();
      }, { passive: true });

      // Event listeners para mouse (escritorio)
      overlay.addEventListener('mousedown', (e: MouseEvent) => {
        isDragging = true;
        startY = e.clientY;
        e.preventDefault(); // Prevenir selección de texto
      });

      overlay.addEventListener('mousemove', (e: MouseEvent) => {
        if (isDragging) {
          endY = e.clientY;
        }
      });

      overlay.addEventListener('mouseup', () => {
        if (isDragging) {
          handleSwipe();
          isDragging = false;
        }
      });

      overlay.addEventListener('mouseleave', () => {
        if (isDragging) {
          isDragging = false;
        }
      });
    });

    function handleSwipe() {
      const swipeDistance = startY - endY;
      
      // Swipe hacia arriba (siguiente video)
      if (swipeDistance > minSwipeDistance) {
        scrollToVideo(currentIndex + 1);
      }
      // Swipe hacia abajo (video anterior)
      else if (swipeDistance < -minSwipeDistance) {
        scrollToVideo(currentIndex - 1);
      }
      
      // Reset
      startY = 0;
      endY = 0;
    }

    // Inicializar navegación
    updateNavigation();
  </script>
</BaseLayout>